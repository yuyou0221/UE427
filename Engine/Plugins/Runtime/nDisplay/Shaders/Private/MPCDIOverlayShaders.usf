// Copyright Epic Games, Inc. All Rights Reserved.
#include "MPCDIUtils.ush"


OutputVS IcvfxWarpVS(InputVS IN)
{
	OutputVS OUT;

#if MESH_WARP
	OUT.PFMPosition = mul(float4(IN.Position.xyz,1.f), MeshToStageProjectionMatrix);
	OUT.UV_Chromakey = float4(IN.UV_Chromakey, 0.f, 1.f);
	float4 ScreenPosition = float4(IN.UV.xy, 0, 1);
#else
	float4 ScreenPosition = IN.Position;	
#endif

	DrawRectangle(ScreenPosition, IN.UV, OUT.Position, OUT.UV.xy);
	OUT.Position.zw = float2(0.f, 1.f);
	OUT.UV = float4(IN.UV, 0.f, 1.f);
	return OUT;
}

OutputPS Passthrough_PS(OutputVS IN)
{
	OutputPS OUT;

	float4 ViewportUV = mul(IN.UV, ViewportTextureProjectionMatrix);	
	float4 ViewportColor = InputTexture.Sample(InputSampler, ViewportUV.xy);

	OUT.Color = ViewportColor;
	return OUT;
}

float4 GetIcvfxOverlayColor(float2 OverlayUV)
{
	float4 OverlayColor = OverlayTexture.Sample(OverlaySampler, OverlayUV).rgba;

#if OVERLAY_ALPHA
	OverlayColor.a = OverlayAlphaTexture.Sample(OverlayAlphaSampler, OverlayUV).a;
#endif

	return OverlayColor;
}

float3 ComposeIcvfxOverlay(float3 OutColor, float2 OverlayUV)
{

	float4 OverlayColor = GetIcvfxOverlayColor(OverlayUV);
	float3 FinalColor = OverlayColor.xyz + OutColor * OverlayColor.w;

	return FinalColor;
}

float4 GetInnerCameraColor(float4 WarpedUV, OutputVS IN)
{
	// Transform WarpedUV to Camera ScreenSpaceUV
	float4 CameraUVW = mul(WarpedUV, InnerCameraProjectionMatrix);
	float2 CameraUV = CameraUVW.xy / CameraUVW.w;


#if CHROMAKEYFRAMECOLOR
	float4 CameraColor = float4(0,0,0,0);
#else
	// ** Incamera Frame **
	float3 CameraBaseColor = InnerCameraTexture.Sample(InnerCameraSampler, CameraUV).rgb;
	float4 CameraColor = float4(CameraBaseColor, 0);
#endif

	// *** Soft Edges **
	if (CameraUVW.w > 0) // clip back plane
	{//Defined texel:
		float2 ToEdge = (CameraUV.xy * 2) - 1.0f; // -1..1
		float Weight = 1 - max(abs(ToEdge.x), abs(ToEdge.y));
		// Near clip Plane tests
		//! UV.z <= UV.w &&
		if (Weight >= 0)
		{
			float2 ToSoftEdge = saturate((abs(ToEdge) - 1.0f + InnerCameraSoftEdge.xy) / InnerCameraSoftEdge.xy);
			float CameraTextureAlpha = Pow2(saturate(1 - Pow2(dot(ToSoftEdge, ToSoftEdge))));
			CameraColor.w = CameraTextureAlpha;
		}
	}

#if CHROMAKEYFRAMECOLOR || CHROMAKEY
	// Use frame color by default
	float4 OverlayChromakeyColor = float4(ChromakeyColor.xyz,0);

#if CHROMAKEY
	float4 ChromakeyCameraTextureColor = ChromakeyCameraTexture.Sample(ChromakeyCameraSampler, CameraUV);

	// Get alpha from chromakey rtt frame
	OverlayChromakeyColor.w = ChromakeyCameraTextureColor.w;
#endif

#if CHROMAKEY_MARKER
	float2 MarkerUV = frac(IN.UV_Chromakey.xy * ChromakeyMarkerScale) * (1+ChromakeyMarkerDistance);
	float2 ChromakeyMarkerUV = saturate(MarkerUV);
	// Border pixels always invisible
	float ChromakeyAlphaMult = 1.f;
	if(any(ChromakeyMarkerUV - MarkerUV))
	{
		ChromakeyAlphaMult = 0.f;
	}
	float4 ChromakeyMarkerTextureColor = ChromakeyMarkerTexture.Sample(ChromakeyMarkerSampler, ChromakeyMarkerUV);
	
	float4 OverlayChromakeyMarkerColor = float4(ChromakeyMarkerColor.xyz, ChromakeyMarkerTextureColor.w);
	
	OverlayChromakeyColor.xyz = lerp(OverlayChromakeyColor.xyz, OverlayChromakeyMarkerColor.xyz, OverlayChromakeyMarkerColor.w * ChromakeyAlphaMult);
#endif

	CameraColor.xyz = lerp(CameraColor.xyz, OverlayChromakeyColor.xyz, 1-OverlayChromakeyColor.w);
#endif

	return CameraColor;
}

OutputPS IcvfxWarpPS(OutputVS IN)
{
	OutputPS OUT;

	// Load warped UV
#if MESH_WARP
	float4 WarpedUV = float4(IN.PFMPosition, 1.f);
#else
	float4 WarpedUV = WarpMapTexture.Sample(WarpMapSampler, IN.UV.xy);
#endif
	
	// Transform WarpedUV to ScreenSpaceUV
	float4 ViewportUVW = mul(WarpedUV, ViewportTextureProjectionMatrix);
	float2 ViewportUV = ViewportUVW.xy / ViewportUVW.w;


	float4 OverlayUVW = mul(WarpedUV, OverlayProjectionMatrix);
	float2 OverlayUV = OverlayUVW.xy / OverlayUVW.w;

	// Compose all:
#if VIEWPORT_INPUT
	// First and single pass renders:
	float4 OutColor = float4(InputTexture.Sample(InputSampler, ViewportUV).rgb, 1.0f);

	#if OVERLAY_UNDER
		OutColor.xyz = ComposeIcvfxOverlay(OutColor.xyz, OverlayUV);
	#endif
	
	#if INNER_CAMERA
		float4 CameraColor = GetInnerCameraColor(WarpedUV, IN);
		OutColor.xyz = lerp(OutColor.xyz, CameraColor.xyz, CameraColor.w);
	#endif

	#if OVERLAY_OVER
		OutColor.xyz = ComposeIcvfxOverlay(OutColor.xyz, OverlayUV);
	#endif

#else 
	// MultiCam or Final renderpass (only cam or overlay per pass))
	#if INNER_CAMERA
		float4 OutColor = GetInnerCameraColor(WarpedUV, IN);
	#else
		#if OVERLAY_OVER
			float4 OutColor = GetIcvfxOverlayColor(OverlayUV);
		#else
			float4 OutColor = float4(0, 0, 0, 0);
		#endif
	#endif
#endif

	//@todo: add LUT here

	// Apply final mpcdi color blending
	OUT.Color = ApplyBlending(OutColor.xyz, IN, OutColor.w);
	return OUT;
}

